LPI <- read.csv(file.choose())
LPI
View(LPI)
View(LPI)
install.packages(tidyr)
install.packages(dplyr)
install.packages(ggplot2)
install.packages(readr)
install.packages(gridExtra)
install.packages("tidyr")
install.packages("dplyr")
install.packages("ggplot2")
install.packages("readr")
install.packages("gridExtra")
library(tidyr)
library(dplyr)
library(ggplot2)
library(readr)
library(gridExtra)
LPI2 <- gather(LPI, "year", "abundance", 9:53)
View(LPI2)
?gather
LPI2$year <- parse_number(LPI2$year)
str(LPI2)
LPI2$abundance <- as.numeric(LPI2$abundance)
Species <- LPI2$Common.Name
view (Species)
Species <- as.character(Species)
view (Species)
show(Species)
bird <- filter(LPI2, Common.Name == "Grey seal")
head(vulture)
bird <- filter(LPI2, Common.Name == "Grey seal")
head(bird)
bird_no_na <- na.omit(bird)
View(bird_no_na)
View(bird_no_na)
base_hist <- hist(bird$abundance)
+ geom_istogram()
base_hist <- hist(bird$abundance)
+ geom_istogram()
library(ggplot2)
library(ggplot2)
base_hist <- hist(bird$abundance)
+ geom_istogram()
base_hist <- hist(bird$abundance)
+ geom_histogram()
base_hist <- ggplot(bird$abundance)
+ geom_histogram()
base_hist <- ggplot(bird$abundance)
+ geom_histogram()
bird <- filter(LPI2, Common.Name == "Grey seal")
head(bird)
bird_no_na <- na.omit(bird)
base_hist <- ggplot(bird$abundance)
+ geom_histogram()
base_hist <- ggplot(bird, aes(x=abundance))
+ geom_histogram()
bird <- filter(LPI2, Common.Name == "Grey seal")
head(bird)
bird <- na.omit(bird)
base_hist <- ggplot(bird, aes(x=abundance))
+ geom_histogram()
base_hist <- ggplot(bird, aes(x=abundance))
+ geom_histogram()
View(bird)
base_hist <- ggplot(bird, aes(x=abundance))
+ geom_histogram()
base_hist <- ggplot(bird, aes(x=abundance)) +
geom_histogram()
base_hist
base_hist <- ggplot(bird, aes(x=abundance)) +
geom_histogram(binwidth = 250, colours = "#8B5A00", fill="CD8409") +
geom_vline(aes(xintercept=mean(abundance)), colours = "red", linetype = "dashed", size = 1) +
theme_bw()
base_hist
base_hist <- ggplot(bird, aes(x=abundance)) +
geom_histogram(binwidth = 250, colours = "#8B5A00", fill="CD8409") +
geom_vline(aes(xintercept=mean(abundance)), colours = "red", linetype = "dashed", size = 1) +
theme_bw()
base_hist <- ggplot(bird, aes(x=abundance))
base_hist <- ggplot(bird, aes(x=abundance)) +
geom_histogram(binwidth = 250, colour = "#8B5A00", fill="CD8409")
base_hist <- ggplot(bird, aes(x=abundance)) +
geom_histogram(binwidth = 250, colour = "#8B5A00", fill="CD8409") +
geom_vline(aes(xintercept=mean(abundance)), colour = "red", linetype = "dashed", size = 1)
base_hist <- ggplot(bird, aes(x=abundance)) +
geom_histogram(binwidth = 250, colour = "#8B5A00", fill="CD8409") +
geom_vline(aes(xintercept=mean(abundance)), colour = "red", linetype = "dashed", size = 1) +
theme_bw()
base_hist
base_hist
base_hist <- ggplot(bird, aes(x=abundance)) +
geom_histogram(binwidth = 250, colour = "#8B5A00", fill="#CD8409") +
geom_vline(aes(xintercept=mean(abundance)), colour = "red", linetype = "dashed", size = 1) +
theme_bw()
base_hist
library(swirl)
swirl()
swirl()
swirl()
data(cars)
?cars
swirl()
swirl()
Sys.Date()
mean(c(2,4,5))
submit()
boring_function("My first function")
boring_function("My first function!")
boring_function()
boring_function
submit
submit()
my_mean(c(4,5,10))
submit()
submit()
reminder(5)
remainder(5)
remainder(11, 5)
remainder(divisor = 11, num = 5)
remainder(4, div = 2)
args(remainder)
submit()
evaluate()
evaluate(std, c(1.4, 3.6, 7.9, 8.8))
evaluate(sd, c(1.4, 3.6, 7.9, 8.8))
evaluate(function(x){x+1},6)
evaluate(function(x){x[1],c(8, 4, 0))
evaluate(function(x){x[1]},c(8, 4, 0))
evaluate(function(x){x[length(x)]},c(8, 4, 0))
?paste
paste("Programming", "is", "fun!")
submit()
telegram("GHESBORO")
submit()
submit()
mad_libs(place = "El to cueo", adjective = "brusa", noun = "Stocasso")
submit()
submit()
submit()
submit()
submit()
submit()
submit()
submit()
submit()
nxt()
nxt()
submit()
skyp()
exit
exit()
quit()
library(swirl)
swirl()
submit()
swirl()
quit
quit()
lapply(list("plyr", #ddply function for dataframe manipulation
"ggmap", #mapping
"ggplot2", #plotting
"leaflet", #interactive mapping
"sp", #spatial point creation
"spdep", #nearest neighbor calculations
"knitr", #output tables - see kable
"tm", #text mining package
"raster", #cropping spatial object
"rgdal", #exporting shapefiles
"spatstat"), #convex hulls
require, character.only = TRUE)
library(dyplr)
.libPaths()
.libPaths("D:/Documents/R-library")
.libPaths()
.libPaths()
.libPaths("D:/Documents/R-library")
.libPaths()
.libPaths(c("D:/Documents/R-library"))
.libPaths()
.libPaths(c(libpath("D:/Documents/R-library")))
.libPaths(c(.libpath("D:/Documents/R-library")))
.libPaths(c(.libPath("D:/Documents/R-library")))
.libPaths(c(.libPaths("D:/Documents/R-library")))
.libPaths()
?.libPaths
.libPaths("D:/Documents/R-library")
.libPaths()
.libPaths()
.libPaths(c(.libpath(),"D:/Documents/R-library"))
.libPaths(c(.libPaths(),"D:/Documents/R-library"))
.libPaths()
.libPaths(c(.libPaths()-1)
.libPaths(c(.libPaths())[1,2])
.libPaths(c(.libPaths())[1])
.libPaths()
.libPaths(c("D:/Documents/R-library",.libPaths()))
.libPaths()
.libPaths()
.libPaths(c("D:/Documents/R-library",.libPaths()))
.libPaths()
.libPaths()
path <- .libPaths()
path
install.packages("dyplr")
install.packages("ggplot2")
.libPaths()
library(ggplot2)
.Rprofile
## Where do you want to create the new site?
setwd("D:/Documents/R_site2")
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
library(sf)
library(raster)
library(dplyr)
# Set WD automatically to where the R scrip is
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
getwd()
r3 <- raster("./facebook_pop/GHS_POP_GPW42015_GLOBE_R2015A_54009_1k_v1_0/population_cod_2018-10-01.tif.tif")
# Set WD automatically to where the R scrip is
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
getwd()
r3 <- raster("./facebook_pop/population_cod_2018-10-01.tif.tif")
r3 <- raster("./facebook_pop/population_cod_2018-10-01.tif")
saveRDS(r2,"./Input/rast_fb_30m.rds")
saveRDS(r3,"./Input/rast_fb_30m.rds")
saveRDS(r3,"./rast_fb_30m.rds")
# install.packages("sf")
# install.packages("dplyr")
library(sf)
library(dplyr)
# Set WD automatically
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
# Check the wd
getwd()
## Loading while setting the Coordinate Reference Systems (CRS) and reprojecting
river.drc <- readRDS("./Input/rivers_drc.rds") %>% st_set_crs(.,4326) %>% st_transform(.,54009)
## Isolate only the geometries for the two rivers of interest
river.drc.sub <- subset(river.drc, HYD_NAME == "SANKURU" | HYD_NAME == "KASAI")
## Dissolve the geometries by river to obtain two lines instead of many
river.drc.sub2 <- river.drc.sub %>% group_by(., HYD_NAME) %>% summarise() %>% ungroup()
## Plot the two rivers
plot(river.drc.sub2, main="Kasai & Sankuru", key.pos=NULL)
## Keep the environment tidy
rm(river.drc, river.drc.sub)
## Create a buffer of 20km and 50km around the rivers
buffer.20km <- st_buffer(river.drc.sub2, dist = 20000, endCapStyle = "ROUND")
plot(buffer.20km, main="Buffer 20km", key.pos=NULL)
buffer.50km <- st_buffer(river.drc.sub2, dist = 50000, endCapStyle = "ROUND")
plot(buffer.50km, main="Buffer 50km", key.pos=NULL)
## Dissolve the buffers in a single polygon
buffer.20.dis <- buffer.20km %>% dplyr::mutate(.,DISS = "all") %>% group_by(., DISS) %>% summarise() %>% ungroup()
plot(buffer.20.dis, main="Buffer 20km dissolved", key.pos=NULL)
buffer.50.dis <- buffer.50km %>% dplyr::mutate(.,DISS = "all") %>% group_by(., DISS) %>% summarise() %>% ungroup()
plot(buffer.50.dis, main="Buffer 50km dissolved", key.pos=NULL)
only.kasai.50 <- subset(buffer.50km, HYD_NAME == "KASAI")
only.sankuru.50 <- buffer.50km %>% filter(., HYD_NAME == "SANKURU") %>% st_difference(.,only.kasai.50) %>% dplyr::select(., -HYD_NAME.1)
only.kasai.20 <- subset(buffer.20km, HYD_NAME == "KASAI")
only.sankuru.20 <- buffer.20km %>% filter(., HYD_NAME == "SANKURU") %>% st_difference(.,only.kasai.50) %>% dplyr::select(., -HYD_NAME.1)
## Keep the environment tidy
rm(buffer.20km,buffer.50km)
# install.packages("tmap")
library(tmap)
## Set a bounding box using the buffer sf to display all the layers entirely
bbox.dis <- st_bbox(buffer.50.dis)
## Create all the map elements
# River map
m.riv <- tmap::tm_shape(river.drc.sub2, bbox = bbox.dis) +  # using bbox here
tm_lines(col = "cyan",lwd = 1, lty = "solid", alpha = 0.3)
# Buffer maps
m.only.kasai.50 <- tmap::tm_shape(only.kasai.50) +
tm_borders(col = "#8470FF", alpha = 0.5)
m.only.sankuru.50 <- tmap::tm_shape(only.sankuru.50) +
tm_borders(col = "#4169E1", alpha = 0.5)
m.only.kasai.20 <- tmap::tm_shape(only.kasai.20) +
tm_borders(col = "#66CD00", alpha = 0.5)
m.only.sankuru.20 <- tmap::tm_shape(only.sankuru.20) +
tm_borders(col = "#008B00", alpha = 0.5)
## Plot all the map elements together
m.riv + m.only.kasai.50 + m.only.sankuru.50 + m.only.kasai.20 + m.only.sankuru.20+
tm_layout(main.title ="River & buffers", main.title.position = "center",frame = FALSE)
## Keep the environment tidy
rm(m.riv, m.only.kasai.50, m.only.sankuru.50, m.only.kasai.20, m.only.sankuru.20, bbox.dis)
## Subset only the villages which are within 50km from the rivers and
## assign to all of them the attribute "50km" in buffer
gaz.drc.50km <- gaz.drc %>% .[subset(buffer.50.dis),] %>% mutate(BUFFER = "50km", AREA = NA)
## Load the gazetteer villages dataset
gaz.drc <- readRDS("./Input/gaz_drc.rds") %>% st_set_crs(.,4326) %>% st_transform(.,54009)
## Remove duplicate geometries contained in the subset of the village file. 6189 -> 5281
gaz.drc.50km <- st_difference(gaz.drc.50km)
## Ensure all the points are within DRC
# Exclude all the points which are without DRC
drc.boundaries <- readRDS("./Input/boundaries_drc_admin0.rds")
gaz.drc.50km <- st_join(gaz.drc.50km,drc.boundaries) %>% subset(., adm0_name == "Democratic Republic of the Congo")
## Set a bounding box using the buffer sf to display all the layers entirely
bbox.dis <- st_bbox(buffer.50.dis)
## Create all the map elements
# River map
m.riv <- tmap::tm_shape(river.drc.sub2, bbox = bbox.dis) +  # using bbox here
tm_lines(col = "cyan",lwd = 1, lty = "solid", alpha = 0.3)
# Buffer maps
m.only.kasai.50 <- tmap::tm_shape(only.kasai.50) +
tm_borders(col = "#8470FF", alpha = 0.5)
m.only.sankuru.50 <- tmap::tm_shape(only.sankuru.50) +
tm_borders(col = "#4169E1", alpha = 0.5)
m.only.kasai.20 <- tmap::tm_shape(only.kasai.20) +
tm_borders(col = "#66CD00", alpha = 0.5)
m.only.sankuru.20 <- tmap::tm_shape(only.sankuru.20) +
tm_borders(col = "#008B00", alpha = 0.5)
## Plot all the map elements together
m.riv + m.only.kasai.50 + m.only.sankuru.50 + m.only.kasai.20 + m.only.sankuru.20+
tm_layout(main.title ="River & buffers", main.title.position = "center",frame = FALSE)
## Keep the environment tidy
rm(m.riv, m.only.kasai.50, m.only.sankuru.50, m.only.kasai.20, m.only.sankuru.20, bbox.dis)
## Load the gazetteer villages dataset
gaz.drc <- readRDS("./Input/gaz_drc.rds") %>% st_set_crs(.,4326) %>% st_transform(.,54009)
## Subset only the villages which are within 50km from the rivers and
## assign to all of them the attribute "50km" in buffer
gaz.drc.50km <- gaz.drc %>% .[subset(buffer.50.dis),] %>% mutate(BUFFER = "50km", AREA = NA)
## Remove duplicate geometries contained in the subset of the village file. 6189 -> 5281
gaz.drc.50km <- st_difference(gaz.drc.50km)
## Ensure all the points are within DRC
# Exclude all the points which are without DRC
drc.boundaries <- readRDS("./Input/boundaries_drc_admin0.rds")
gaz.drc.50km <- st_join(gaz.drc.50km,drc.boundaries) %>% subset(., adm0_name == "Democratic Republic of the Congo")
## Assign the correct sector/territory/province to the village points
# Load the sector file anbd keep only the attributes of interest
drc.sectors <- readRDS("./Input/boundaries_drc_sectors.rds") %>%
subset(., select = c(nom_prov,nom_distri,nom_terri,nom_sec))# already in 54009 projection
# Spatial join between the villages and the sector to get the info in the attribute table
gaz.drc.50km <- st_join(gaz.drc.50km,drc.sectors)
## Calculate logic vectors used to re-assign the labels
lo.only.kasai.50 <- st_intersects(gaz.drc.50km, only.kasai.50, sparse = FALSE)
lo.only.sank.50 <- st_intersects(gaz.drc.50km, only.sankuru.50, sparse = FALSE)
lo.buff.20 <- st_intersects(gaz.drc.50km, buffer.20.dis, sparse = FALSE)
## Re-assing the labels
gaz.drc.50km <- gaz.drc.50km %>%
mutate(AREA = replace(AREA, lo.only.kasai.50, "kasai" )) %>%
mutate(AREA = replace(AREA, lo.only.sank.50, "sankuru" )) %>%
mutate(BUFFER = replace(BUFFER, lo.buff.20, "20km" ))
## Check the numbers of villages within each buffer area
gaz.drc.50km %>% group_by(AREA,BUFFER) %>%  summarise(n = n()) %>% ungroup()
## Keep the environment tidy
rm(gaz.drc, drc.boundaries, drc.sectors, lo.only.kasai.50, lo.only.sank.50, lo.buff.20)
# install.packages("raster")
library(raster)
## Load the population raster with resolution 1km
rast.ghsl.1km <- readRDS("./Input/rast_ghsl_1km.rds") #raster has already 54009 projection
## Aggregation of the GHSL raster from 1km x 1km to a 2km x 2km raster (sum not average)
rast.ghsl.2km <- raster::aggregate(rast.ghsl.1km,fact=2,fun=sum)
## Load the population raster with resolution 1km
rast.ghsl.1km <- readRDS("./Input/rast_ghsl_1km.rds") #raster has already 54009 projection
## Aggregation of the GHSL raster from 1km x 1km to a 2km x 2km raster (sum not average)
rast.ghsl.2km <- raster::aggregate(rast.ghsl.1km,fact=2,fun=sum)
r2 <- raster("./ghsl/GHS_POP_GPW42015_GLOBE_R2015A_54009_1k_v1_0/GHS_POP_GPW42015_GLOBE_R2015A_54009_1k_v1_0.tif")
# Set WD automatically to where the R scrip is
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
r2 <- raster("./ghsl/GHS_POP_GPW42015_GLOBE_R2015A_54009_1k_v1_0/GHS_POP_GPW42015_GLOBE_R2015A_54009_1k_v1_0.tif")
saveRDS(r2,"./rast_ghsl_30m.rds")
# Set WD automatically
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
## Load the population raster with resolution 1km
rast.ghsl.1km <- readRDS("./Input/rast_ghsl_1km.rds") #raster has already 54009 projection
## Aggregation of the GHSL raster from 1km x 1km to a 2km x 2km raster (sum not average)
rast.ghsl.2km <- raster::aggregate(rast.ghsl.1km,fact=2,fun=sum)
writeRaster(rast.ghsl.2km, filename="GHSL_2km_.tif", format="GTiff")
## Calculate the number of villages per each cell in a raster 2km x 2km with the same exact dimension of rast.ghsl.2km
# Get the raster r.points with the same dimension as rast.ghsl.2km but filled with zeros
r.points <- rast.ghsl.2km
r.points[] <- 0
# Transform the sf in a spatial dataframe compatible with functions that require sp objects
xy <- as(gaz.drc.50km, 'Spatial')
tab <- table(cellFromXY(r.points, xy))
r.points[as.numeric(names(tab))] <- tab
### Extract the values from the population raster
gaz.drc.val <- as.data.frame(raster::extract(rast.ghsl.2km, gaz.drc.50km, method="simple"))
# Rename the column and add it to the villages 50km dataset
colnames(gaz.drc.val) <- c("ghsl_pop_agg")
gaz.drc.50km <- cbind(gaz.drc.50km,gaz.drc.val$ghsl_pop_agg)
# Rename the column
colnames(gaz.drc.50km)[length(gaz.drc.50km )-1] <- "ghsl_totpop"
### Extract the values from the village-count raster
gaz.drc.val2 <- as.data.frame(raster::extract(r.points, gaz.drc.50km, method="simple"))
# Rename the column and add it to the villages 50km dataset
colnames(gaz.drc.val2) <- c("vil_count")
gaz.drc.50km <- cbind(gaz.drc.50km,gaz.drc.val2$vil_count)
# Rename the column
colnames(gaz.drc.50km)[length(gaz.drc.50km )-1] <- "vilcount"
### Calculate the estimate population
## In case two or more points are within a 2km x 2km square the population count
## will be evenly divided among them. We also discard intermediate columns.
gaz.drc.50km <- gaz.drc.50km %>% mutate(.,pop_avg = (ghsl_totpop/vilcount)) %>% subset(., select= -c(ghsl_totpop,vilcount))
## Export the shapefile with the projected coordinates
st_write(gaz.drc.50km, "./Output/gaz.drc.50km_merc.shp")
## Export the shapefile re-projected as WGS84 spherical including the coordinates of each point
gaz.drc.50km %>% st_transform(.,4326) %>%  mutate(LONG = st_coordinates(.)[,1]) %>%  mutate(LAT = st_coordinates(.)[,2]) %>% st_write(., "./Output/gaz.drc.50km_wgs84.shp")
## Export the csv re-projected as WGS84 spherical including the coordinates of each point
gaz.drc.50km %>% st_transform(.,4326) %>%  mutate(LONG = st_coordinates(.)[,1]) %>%  mutate(LAT = st_coordinates(.)[,2]) %>% st_write(., 'Output/gaz.drc.50km.csv')
load("D:/Documents/R_portfolio/.RData")
